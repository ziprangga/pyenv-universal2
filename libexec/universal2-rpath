#!/usr/bin/env bash
set -e

source "$(dirname "${BASH_SOURCE[0]}")/tools/u2-utility"
source "$(dirname "${BASH_SOURCE[0]}")/tools/u2-core"

single_update(){
    local python_dir="$1"   
    local temp_dir="$2"

    local only_int="false"
    local only_ext="false"

    for arg in "$@"; do
        case $arg in
            --int=*) only_int="${arg#*=}" ;;
            --ext=*) only_ext="${arg#*=}" ;;
            *)
                log "WARN" "Unknown argument: $arg"
                return 1
                ;;
        esac
    done


    local target_path_int target_path_ext
    target_path_int=$(find "$python_dir" -type d -name "lib" 2>/dev/null | head -n 1)
    target_path_ext=$(find "$python_dir" -type d -name "deps" 2>/dev/null | head -n 1)

    if [[ -n "$target_path_ext" && -n "$target_path_int" ]]; then
        local target_id_int_path="@rpath/$(basename "$target_path_int")"
        local target_id_ext_path="@rpath/$(basename "$target_path_ext")"
    fi

    color_echo "INFO" "Create environment"
    local temp_metadata="$temp_dir/metadata"
    local temp_collected_binary="$temp_dir/collected_dir"
    run_if_not_dry mkdir -p "$temp_dir" "$target_path_ext" "$temp_metadata" "$temp_collected_binary"

    color_echo "INFO" "Scan binary & collect external binary"
    local cache_scanner="$temp_metadata/scanner.txt"
    local temp_merge_metadata="$temp_metadata/merge_bin.txt"
    local temp_collected_metadata="$temp_metadata/collected_bin.txt"
    scan_binary_and_cache "$python_dir" "$cache_scanner"

    color_echo "INFO" "Update binary LC_LOAD_DYLIB, LC_RPATH, & LC_ID_DYLIB"
    if [[ "$only_ext" == "true" ]]; then
        if [[ -n "$target_path_ext" ]]; then
            shopt -s nullglob
            for binary in "$target_path_ext"/*; do
                update_lc_load_dylib --binary="$binary" --ext="$target_path_ext"
                update_lc_rpath --binary="$binary" --ext="$target_path_ext"
                update_lc_id_dylib "$binary" "$target_id_ext_path"
            done
            shopt -u nullglob
            resign_all_binaries "$target_path_ext"
        else
            color_echo "ERROR" "Missing external independent binary, plesae collect it first.."
        fi
        color_echo "INFO" "External-only update complete"
        return 0
    fi

    while IFS=$'\n' read -r binary; do
        if [[ "$only_int" == "true" ]]; then
            [[ "$binary" == "$target_path_ext"* ]] && continue
        fi

        if [[ -n "$target_path_ext" && -n "$target_path_int" ]]; then
            update_lc_load_dylib --binary="$binary" --int="$target_path_int" --ext="$target_path_ext"
            update_lc_rpath --binary="$binary" --int="$target_path_int" --ext="$target_path_ext"
        elif [[ -n "$target_path_ext" && -z "$target_path_int" ]]; then
            update_lc_load_dylib --binary="$binary" --ext="$target_path_ext"
            update_lc_rpath --binary="$binary" --ext="$target_path_ext"
        elif [[ -z "$target_path_ext" && -n "$target_path_int" ]]; then
            update_lc_load_dylib --binary="$binary" --int="$target_path_int"
            update_lc_rpath --binary="$binary" --int="$target_path_int"
        fi

        if [[ "$binary" == "$target_path_ext"* ]]; then
            update_lc_id_dylib "$binary" "$target_id_ext_path"
            resign_all_binaries "$binary"
        else
            update_lc_id_dylib "$binary" "$target_id_int_path"
        fi
    done < "$cache_scanner"

    color_echo "INFO" "All process completed"
}

fat_update() {
    local python_dir="$1"   
    local temp_dir="$2"

    local only_int="false"
    local only_ext="false"

    for arg in "$@"; do
        case $arg in
            --int=*) only_int="${arg#*=}" ;;
            --ext=*) only_ext="${arg#*=}" ;;
            *)
                log "WARN" "Unknown argument: $arg"
                return 1
                ;;
        esac
    done


    local target_path_int target_path_ext
    target_path_int=$(find "$python_dir" -type d -name "lib" 2>/dev/null | head -n 1)
    target_path_ext=$(find "$python_dir" -type d -name "deps" 2>/dev/null | head -n 1)

    if [[ -n "$target_path_ext" && -n "$target_path_int" ]]; then
        local target_id_int_path="@rpath/$(basename "$target_path_int")"
        local target_id_ext_path="@rpath/$(basename "$target_path_ext")"
    fi

    color_echo "INFO" "Create environment"
    local temp_metadata="$temp_dir/metadata"
    local temp_int_collected_arm="$temp_dir/int_binary_arm"
    local temp_int_collected_x86="$temp_dir/int_binary_x86"
    run_if_not_dry mkdir -p "$temp_dir" "$target_path_ext" "$temp_metadata" "$temp_int_collected_arm" "$temp_int_collected_x86"

    color_echo "INFO" "Scan binary"
    local cache_scanner="$temp_metadata/scan_python.txt"
    local temp_merge_metadata="$temp_metadata/merge_binary.txt"
    scan_binary_and_cache "$python_dir" "$cache_scanner"

    color_echo "INFO" "Extract fat binary"
    while IFS=$'\n' read -r binary; do
        extract_fat_binary "$binary" "$temp_int_collected_arm" "$temp_int_collected_x86"
    done < "$cache_scanner"

    color_echo "INFO" "Update binary LC_LOAD_DYLIB, LC_RPATH, & LC_ID_DYLIB"
    if [[ "$only_ext" == "true" ]]; then
        if [[ -n "$target_path_ext" ]]; then
            shopt -s nullglob
            for arch_dir in "$temp_int_collected_x86" "$temp_int_collected_arm"; do
                for binary in "$arch_dir"/*; do
                    [[ "$binary" != "$target_path_ext"* ]] && continue
                    update_lc_load_dylib --binary="$binary" --ext="$target_path_ext"
                    update_lc_rpath      --binary="$binary" --ext="$target_path_ext"
                done
            done

            for binary in "$target_path_ext"/*; do
                local relative_path="${binary#$target_path_ext/}"
                local base_name_ext_lib=$(basename $relative_path)
                local arm_ext_binary="$temp_int_collected_arm/$base_name_ext_lib"
                local x86_ext_binary="$temp_int_collected_x86/$base_name_ext_lib"
                local merged_binary="$binary"

                color_echo "INFO" "Merge external binary"
                merge_binary_or_lib "$x86_ext_binary" "$arm_ext_binary" "$merged_binary" "$temp_merge_metadata"

                color_echo "INFO" "Update external LC_ID_DYLIB"
                update_lc_id_dylib "$merged_binary" "$target_id_ext_path"

                resign_all_binaries "$merged_binary"
            done
            shopt -u nullglob
        else
            color_echo "ERROR" "Missing external independent binary, plesae collect it first.."
        fi
        color_echo "INFO" "External-only update complete"
        return 0
    fi

    shopt -s nullglob
    for arch_dir in "$temp_int_collected_x86" "$temp_int_collected_arm"; do
        for binary in "$arch_dir"/*; do
            [[ "$only_int" == "true" && "$binary" == "$target_path_ext"* ]] && continue

            if [[ -n "$target_path_ext" && -n "$target_path_int" ]]; then
                update_lc_load_dylib --binary="$binary" --int="$target_path_int" --ext="$target_path_ext"
                update_lc_rpath      --binary="$binary" --int="$target_path_int" --ext="$target_path_ext"
            elif [[ -n "$target_path_ext" ]]; then
                update_lc_load_dylib --binary="$binary" --ext="$target_path_ext"
                update_lc_rpath      --binary="$binary" --ext="$target_path_ext"
            elif [[ -n "$target_path_int" ]]; then
                update_lc_load_dylib --binary="$binary" --int="$target_path_int"
                update_lc_rpath      --binary="$binary" --int="$target_path_int"
            fi
        done
    done
    shopt -u nullglob

    while IFS=$'\n' read -r binary; do
        [[ "$only_int" == "true" && "$binary" == "$target_path_ext"* ]] && continue

        local relative_path="${binary#$python_dir/}"
        local base_name_ext_lib=$(basename $relative_path)
        local arm_binary="$temp_int_collected_arm/$base_name_ext_lib"
        local x86_binary="$temp_int_collected_x86/$base_name_ext_lib"
        local merged_binary="$binary"

        color_echo "INFO" "Merge external binary"
        merge_binary_or_lib "$x86_binary" "$arm_binary" "$merged_binary" "$temp_merge_metadata"

        if [[ "$binary" == "$target_path_ext"* ]]; then
            update_lc_id_dylib "$binary" "$target_id_ext_path"
            resign_all_binaries "$merged_binary"
        else
            update_lc_id_dylib "$binary" "$target_id_int_path"
        fi
    done < "$cache_scanner"

    color_echo "INFO" "All process completed"
}

universal2_update_rpath(){
    local python_version="$1"
    local python_dir="$2"   
    local temp_dir="$PYENV_ROOT/temp_dir/${python_version}_temp"

    local only_int="false"
    local only_ext="false"

    for arg in "$@"; do
        case $arg in
            --int=*) only_int="${arg#*=}" ;;
            --ext=*) only_ext="${arg#*=}" ;;
            *)
                log "WARN" "Unknown argument: $arg"
                return 1
                ;;
        esac
    done

    local minor_version
    minor_version="${python_version%.*}"
    local python_binary="$python_dir/bin/python${minor_version}"

    $DRY_RUN || mkdir -p "$temp_dir"

    if lipo -info "$python_binary" | grep -q "Non-fat"; then
        local saved_scan_log="$temp_dir/${python_version}_scan.txt"
        single_update "$python_dir" "$temp_dir" --int="$only_int" --ext="$only_ext"
    else
        local saved_scan_log="$temp_dir/${python_version}_scan_extract.txt"
        fat_update "$python_dir" "$temp_dir" --int="$only_int" --ext="$only_ext"
    fi

    $DRY_RUN || cleanup_temp "$temp_dir"
    log "INFO" "Successfully updated all fat binaries in $python_dir"
}
