#!/usr/bin/env bash

path_regex() {
    if [[ -z "$ARM_BREW_DIR" || -z "$X86_BREW_DIR" ]]; then
        color_echo "ERROR" "ARM_BREW_DIR or X86_BREW_DIR not set."
        return 1
    fi

    ARM_BREW_DIR_ESCAPED=$(echo "$ARM_BREW_DIR" | sed 's|/|\\/|g')
    X86_BREW_DIR_ESCAPED=$(echo "$X86_BREW_DIR" | sed 's|/|\\/|g')

    BREW_PATH_REGEX="^(${ARM_BREW_DIR_ESCAPED}|${X86_BREW_DIR_ESCAPED})/(opt|Cellar)"
}

scan_dylib(){
    local python_dir="$1"
    local temp_folder="$2"
    find "$python_dir" -type f \( -name "*.dylib" -o -name "*.so" \) -print \
        -o -type f -exec sh -c '
            for file; do
                if file "$file" | grep -qE "Mach-O.*executable"; then
                    echo "$file"
                fi
            done
        ' sh {} +
}

extract_fat_binary(){
    local python_dir="$1"
    local temp_folder="$2"
    local output_file="$3"

    : > "$output_file"

    while IFS= read -r binary; do
        [[ -f "$binary" ]] || continue

        color_echo "INFO" "Processing binary: $binary"

        local binary_name
        binary_name=$(basename "$binary")

        if ! lipo -info "$binary" | grep -q "fat"; then
            log "INFO" "$binary is not a fat binary, skipping extraction."
            continue
        fi

        local x86_binary="$temp_folder/${binary_name}_x86"
        local arm_binary="$temp_folder/${binary_name}_arm"

        # Split the fat binary
        $DRY_RUN || lipo -extract x86_64 "$binary" -output "$x86_binary"
        $DRY_RUN || lipo -extract arm64 "$binary" -output "$arm_binary"

        echo "$binary|$x86_binary|$arm_binary" >> "$output_file"
        
    done < <(scan_dylib "$python_dir")
}

update_lc_id_dylib() {
    local lib="$1"

    local base_name
    base_name=$(basename "$lib")
    local new_id="@rpath/$base_name"

    log "INFO" "Setting LC_ID_DYLIB for $lib to $new_id"
    $DRY_RUN || install_name_tool -id "$new_id" "$lib"
}

update_lc_load_dylib() {
    local binary="$1"
    local target_path="$2"

    color_echo "DEBUG" "Checking Python binary at $binary"

    if [[ ! -f "$binary" ]]; then
        log "WARN" "Error: Python binary not found at $binary"
        log "INFO" "Please verify the Python version and binary path."
        exit 1
    fi

    local libraries
    libraries=$(otool -l "$binary" | awk '/cmd LC_RPATH/,/path/' | grep path | awk '{print $2}')

    log "INFO" "Existing LC_RPATH entries in $binary:"
    log "INFO" "$libraries"

    while IFS= read -r library; do
        [[ -n "$library" ]] || continue

        if [[ "$library" == /usr/lib/* || "$library" == /System/Library/* ]]; then
            color_echo "DEBUG" "Skipping system library: $library"
            continue

        elif [[ "$library" =~ $BREW_PATH_REGEX ]]; then
            local new_path="${target_path}/deps"
            if [[ -d "$new_path" ]]; then
                $DRY_RUN || install_name_tool -rpath "$library" "$new_path" "$binary"
                log "INFO" "Successfully updated LC_RPATH: $library -> $new_path"
            else
                log "WARN" "Error: Failed to update LC_RPATH for $library."
            fi
        elif [[ "$library" != "$target_path"* ]]; then
            local new_path="${target_path}/lib"
            if [[ -d "$new_path" ]]; then
                $DRY_RUN || install_name_tool -rpath "$library" "$new_path" "$binary"
                log "INFO" "Successfully updated LC_RPATH: $library -> $new_path"
            else
                log "WARN" "Error: Failed to update LC_RPATH for $library."
            fi
        else
            log "WARN" "LC_RPATH $library does not match criteria, skipping."
        fi
    done <<< "$libraries"
}

update_lc_rpath() {
    local binary="$1"
    local target_path="$2"

    local libraries
    libraries=$(otool -L "$binary" | awk 'NR>1 {print $1}' || true)

    while IFS= read -r library; do
        [[ -n "$library" ]] || continue

        local base_name
        base_name=$(basename "$library")

        if [[ "$library" == /usr/lib/* || "$library" == /System/Library/* ]]; then
            color_echo "DEBUG" "Skipping system library: $library"
            continue

        elif [[ "$library" =~ $BREW_PATH_REGEX ]]; then
            local new_path="${target_path}/deps/${base_name}"
            if [[ -f "$new_path" ]]; then
                $DRY_RUN || install_name_tool -change "$library" "$new_path" "$binary"
                log "INFO" "Updated rpath external: $library -> $new_path"
            else
                log "WARN" "Warning: Target $new_path not found for brew library, skipping."
            fi

        elif [[ "$library" != "$target_path"* ]]; then
            local new_path="${target_path}/lib/${base_name}"
            if [[ -f "$new_path" ]]; then
                $DRY_RUN || install_name_tool -change "$library" "$new_path" "$binary"
                log "INFO" "Updated rpath internal: $library -> $new_path"
            else
                log "WARN" "Warning: Target $new_path not found for internal library, skipping."
            fi

        else
            color_echo "DEBUG" "Already correct rpath: $library"
        fi

    done <<< "$libraries"
}

merge_libraries() {
    local arm_binary="$1"
    local x86_binary="$2"
    local merged_binary="$3"

    log "INFO" "Merging $arm_binary and $x86_binary into $merged_binary"

    if [[ ! -f "$arm_binary" || ! -f "$x86_binary" ]]; then
        log "ERROR" "One or both binaries are missing, cannot merge."
        return 1
    fi

    $DRY_RUN || lipo -create "$arm_binary" "$x86_binary" -output "$merged_binary"
    if [[ $? -eq 0 ]]; then
        log "INFO" "Successfully merged $arm_binary and $x86_binary into $merged_binary"
    else
        log "ERROR" "Failed to merge binaries: $arm_binary and $x86_binary"
        return 1
    fi
}

collect_ext_lib(){
    local binary="$1"
    local temp_folder="$2"

    local seen_file="$temp_folder/.seen_libs"
    touch "$seen_file"

    local libs
    libs=$(otool -L "$binary" | awk 'NR>1 {print $1}' | grep -E "$BREW_PATH_REGEX" || true)

    if [[ -n "$libs" ]]; then
        color_echo "INFO" "Found binary: $binary"

        while IFS= read -r lib; do
            color_echo "INFO" "Binary $binary is linked with library: $lib"
        done <<< "$libs"
    else
        color_echo "INFO" "Skipping binary (no external libraries): $binary"
    fi

    for lib in $libs; do
        local real_lib
        real_lib=$(readlink -f "$lib" 2>/dev/null || realpath "$lib")
        [[ -z "$real_lib" ]] && real_lib="$lib"

        # Avoid re-processing
        if grep -Fxq "$real_lib" "$seen_file"; then
            log "DEBUG" "Already processed: $real_lib"
            continue
        fi
        echo "$real_lib" >> "$seen_file"

        local base_name
        base_name=$(basename "$real_lib")
        local dest_path="$temp_folder/$base_name"

        if [[ ! -f "$dest_path" ]]; then
            $DRY_RUN || cp "$real_lib" "$dest_path"
            log "INFO" "Copied $real_lib to $dest_path"
            collect_ext_lib "$real_lib" "$temp_folder"
        else
            log "DEBUG" "Already copied: $base_name"
        fi
    done
}

process_collected_ext_libs() {
    local lib_folder="$1"
    local target_path="$2"

    shopt -s nullglob
    for lib in "$lib_folder"/*.dylib; do
        [[ -f "$lib" ]] || continue

        if ! file "$lib" | grep -qE "Mach-O.*dynamically linked shared library"; then
            log "WARN" "Skipping non-dylib file: $lib"
            continue
        fi

        local base_name
        base_name=$(basename "$lib")
        local new_id="@rpath/$base_name"

        # Update the RPATH for the collected lib
        update_lc_rpath "$lib" "$target_path"

        # Update LC_RPATH for the collected lib
        update_lc_load_dylib "$lib" "$target_path"

        # Set LC_ID_DYLIB for the collected lib
        log "INFO" "Setting LC_ID_DYLIB for $lib to $new_id"
        update_lc_id_dylib "$lib"
    done
    shopt -s nullglob
}

merge_ext_lib(){
    local arm_lib_folder="$1"
    local x86_lib_folder="$2"
    local target_lib_path="$3"

    local merged_count=0
    mkdir -p "$target_lib_path"

    shopt -s nullglob
    for arm_binary in "$arm_lib_folder"/*.dylib; do
        [[ -f "$arm_binary" ]] || continue
        local base_name
        base_name=$(basename "$arm_binary")
        local x86_binary="$x86_lib_folder/$base_name"
        local merged_file="$target_lib_path/$base_name"

        log "INFO" "Merged $arm_binary with $x86_binary into $merged_file"
        $DRY_RUN || merge_libraries "$arm_binary" "$x86_binary" "$merged_file"
        if [[ $? -eq 0 ]]; then
            ((merged_count++))
        fi
    done
    shopt -s nullglob

    if [[ $merged_count -eq 0 ]]; then
        log "WARN" "No libraries merged. Please check input folders."
    else
        log "INFO" "Merged $merged_count libraries into $target_lib_path"
    fi
}

update_binary_rpath_and_merge() {
    local x86_binary="$1"
    local arm_binary="$2"
    local target_path="$3"
    local binary="$4"

    # Update RPATH separately
    $DRY_RUN || update_lc_rpath "$x86_binary" "$target_path"
    $DRY_RUN || update_lc_rpath "$arm_binary" "$target_path"

    # Update LC_RPATH separately
    $DRY_RUN || update_lc_load_dylib "$x86_binary" "$target_path"
    $DRY_RUN || update_lc_load_dylib "$arm_binary" "$target_path"

    # update LC_ID_DYLIB
    $DRY_RUN || update_lc_id_dylib "$x86_binary"
    $DRY_RUN || update_lc_id_dylib "$arm_binary"

    # Merge back
    $DRY_RUN || merge_libraries "$x86_binary" "$arm_binary" "$binary"
}

collect_and_merge_ext_lib(){
    local x86_binary="$1"
    local arm_binary="$2"
    local target_path="$3"
    local temp_folder="$4"

    # collect ext lib
    $DRY_RUN || collect_ext_lib "$x86_binary" "$temp_folder/ext_lib_x86"
    $DRY_RUN || collect_ext_lib "$arm_binary" "$temp_folder/ext_lib_arm"

    # process ext lib
    $DRY_RUN || process_collected_ext_libs "$temp_folder/ext_lib_x86" "$target_path"
    $DRY_RUN || process_collected_ext_libs "$temp_folder/ext_lib_arm" "$target_path"

    # merge ext lib
    $DRY_RUN || merge_ext_lib "$temp_folder/ext_lib_arm" "$temp_folder/ext_lib_x86" "$target_path/deps"
}

resign_all_binaries() {
    local path="$1"
    find "$path" -type f \( -name "*.dylib" -o -name "*.so" -o -name "python3*" \) | while read -r file; do
        codesign --force --sign - "$file"
        log "INFO" "Re-signed $file"
    done
}

rpath_updater(){
    local python_version="$1"
    local python_path="$2"

    local target_path="$python_path"
    local minor_version
    minor_version=$(echo "$python_version" | cut -d. -f1,2)
    local python_binary="$python_path/bin/python${minor_version}"
    local temp_folder="$PYENV_ROOT/temp_dir"
    local python_dir
    python_dir=$(dirname "$(dirname "$python_binary")")
    

    $DRY_RUN || mkdir -p "$temp_folder"
    $DRY_RUN || mkdir -p "$temp_folder/ext_lib_x86"
    $DRY_RUN || mkdir -p "$temp_folder/ext_lib_arm"
    $DRY_RUN || mkdir -p "$target_path/deps"

    path_regex
    local extract_log="$temp_folder/extracted.txt"
    extract_fat_binary "$python_dir" "$temp_folder" "$extract_log"
    while IFS='|' read -r binary x86_binary arm_binary; do
        collect_and_merge_ext_lib "$x86_binary" "$arm_binary" "$target_path" "$temp_folder"
        update_binary_rpath_and_merge "$x86_binary" "$arm_binary" "$target_path" "$binary"
    done < "$extract_log"

    resign_all_binaries "$target_path/deps"

    $DRY_RUN || rm -rf "$temp_folder"
    log "INFO" "Successfully updated all fat binaries in $python_dir"
}